proposalSigning - это смарт-контракт на блокчейне BNB testnet, который позволяет подписывать. Это может быть полезно для различных целей.

## Для начала:

Склонируйте проект:
```bash
git clone https://github.com/Arthas-Menethil-599/proposalSigning.git
cd proposalSigning
```
В случае отсутствия:
```bash
npm install
```
Запустите сервер разработки с помощью комманд:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

Откройте [http://localhost:3000](http://localhost:3000) с помощью браузера, чтобы увидеть результат.


## VerifyLeaf

Функция verifyLeaf выполняет проверку листа в дереве Merkle и возвращает значение типа bool, указывающее, принадлежит ли указанный лист дереву Merkle.

Входные параметры функции:

leaf: значение листа, который требуется проверить. <br/>
proof: массив, содержащий значения доказательства, необходимые для проверки листа. <br/>

Работа функции заключается в выполнении следующих шагов: <br/>

Начальное значение переменной hash устанавливается равным значению проверяемого листа leaf.

Для каждого элемента proofElement в массиве proof вычисляется новое значение hash путем объединения текущего значения hash с proofElement и хэширования результата.
Если hash равен корню дерева Merkle, то функция возвращает true, иначе false.

Таким образом, функция verifyLeaf используется для проверки, принадлежит ли определенный лист дереву Merkle, на основе значения листа и доказательства, в котором указано расположение листа в дереве. Эта функция может быть использована для проверки подлинности данных, таких как транзакции или участники в airdrop-программах, используя дерево Merkle в качестве инструмента безопасности.

![image](https://user-images.githubusercontent.com/66798677/228098562-54cd1cf7-5a8f-4b87-bf68-91eed4c520ce.png)

Для того чтобы воспользоваться verifyLeaf, вам достаточно ввести в первое поле адрес и во второе пруфы которые доказывают принадлежность адреса к MerkleTree, соотвественно к подписанию. Таким образом при верном вводе данных и подтверждением принадлежности всплывёт данное окно:

![image](https://user-images.githubusercontent.com/66798677/228097066-1bdc9253-3da5-4645-a9a9-05ec26a06520.png)

Визуально подверждающее вашу принадлежность к подписанию.

Адреса используются заранее установленные для подписания, также в самом коде смарт-контракта в комментариях указаны входные данные для теста
![image](https://user-images.githubusercontent.com/66798677/228097259-a93d8fd5-d944-4c3b-848d-fc5dffde7e7b.png)

Также в случае неверных данных, или отсуствием вашей принадлежности к подписанию выходит данный визуальный элемент в виде notification.
![image](https://user-images.githubusercontent.com/66798677/228097454-b3b56daf-211c-4606-9220-729d352fbd2b.png)




## SignIn

Функция SignIn позволяет участникам получить токены в рамках подписания.

Входной параметр функции:

_proof: массив значений, содержащий доказательство принадлежности адреса пользователя к дереву Merkle. <br/>

Работа функции заключается в выполнении следующих шагов: <br/>

Вызов require, который проверяет, что адрес, от имени которого выполняется функция SignIn, еще не запросил подписание. Если адрес уже запросил выплату, функция будет остановлена и возвратит сообщение об ошибке.

Создание хэша leaf на основе адреса, от имени которого выполняется функция, с помощью функции keccak256.

Вызов функции verifyLeaf для проверки того, что хэш leaf принадлежит дереву Merkle. Если доказательство _proof не соответствует указанному листу leaf в дереве, функция будет остановлена и возвратит сообщение об ошибке.

Установка значения флага claimed[msg.sender] в true, чтобы пометить, что адрес уже получил свою долю токенов.

Вызов внутренней функции _mint, которая выполняет выпуск новых токенов и отправляет их на адрес, от имени которого выполняется функция.

Таким образом, функция SignIn проверяет, что пользователь имеет право на получение токенов в рамках подписания, на основе его адреса и доказательства принадлежности к дереву Merkle. Если пруфы неверны, функция вернет сообщение об ошибке.

![image](https://user-images.githubusercontent.com/66798677/228098723-f8c1ba3c-0e90-47c6-a133-f72f6761a36d.png)

В случае с SignIn, нужно ввести пруфы, а именно соседние хеши соседних адресов, которые также прописаны в комментариях смарт-контракта:
![image](https://user-images.githubusercontent.com/66798677/228097748-47663a68-8f88-418f-a571-2a3a65024af4.png)

Также имеются такие же визуальные элементы подверждающие успешное подписание или неуспешное.

## Rainbowkit

Также реализована возможность подключать разные кошельки с помощью библиотеки Rainbowkit:

![image](https://user-images.githubusercontent.com/66798677/228099587-96125644-691e-4b38-a104-96852ea38e8a.png)

![image](https://user-images.githubusercontent.com/66798677/228099711-ea585d5e-f322-4aed-a462-27414902dea9.png)


## Фронт

Фронт реализован используя next.js + typescript
В стиле "Неоморфизм"

Для реализации взаимодействия фронта со смарт-контрактом нам необходимы address, abi контракта

Также нам нужен signer и contract

signer - объект Signer из библиотеки ethers.js. Signer используется для подписывания транзакций, отправки запросов на выполнение методов контракта и взаимодействия с блокчейном.

contract - объект Contract из библиотеки ethers.js. Contract используется для взаимодействия с контрактом. Он хранит адрес контракта, его ABI и обработчик транзакций (в данном случае, объект signer).

Ну и конечно provider:
const provider = new ethers.providers.Web3Provider((window as any).ethereum)
 - создание объекта Web3Provider из библиотеки ethers.js. Web3Provider используется для взаимодействия с сетью через провайдера Web3, который доступен в окне браузера.

Данная функция необходима для notification в случае успеха и нет

A функция **encodePackedKeccak256** принимает строковое входное значение и возвращает строковый вывод, который представляет хэш-значение входной строки с использованием алгоритма keccak256
Функция **parseHexArray** для того чтобы распарсить proofs которые передаются как JSON объект

Функция **SignIn** достающая value из поля ввода и используя функцию из смарт-контракта, передающая параметр после того как распарсится в массив строк (с обработкой ошибок и дальнейшей передачей в notification для визуального уведомления пользователя)

Функция **verifyLeafIn** достающая адрес и доказательства, адрес переводится в хэш-значение с использованием алгоритма keccak256, а пруфы парсятся в массив строк и передаются в контракт, также происходит обработка ошибок и передача в notification:
![image](https://user-images.githubusercontent.com/66798677/228101769-b26dd7db-0e7b-45a8-8372-e34c5614b96b.png)


**Logo**
![image](https://user-images.githubusercontent.com/66798677/228102008-22400081-0cb9-4d17-8236-a1d86c0bb787.png)

Также в проекте была зайдействована библиотека AntDesign
