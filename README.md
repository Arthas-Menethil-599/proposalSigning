TokenDrop - это смарт-контракт на блокчейне BNB testnet, который позволяет распределять токены ERC20 по списку адресов BNB testnet. Это может быть полезно для различных целей, таких как айрдроп, раздача токенов или поощрительные программы.

## Для начала:

Склонируйте проект:
```bash
git clone https://github.com/Arthas-Menethil-599/tokendrop.git
cd tokendrop
```
В случае отсутствия:
```bash
npm install
```
Запустите сервер разработки с помощью комманд:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

Откройте [http://localhost:3000](http://localhost:3000) с помощью браузера, чтобы увидеть результат.

![image](https://user-images.githubusercontent.com/66798677/228096730-f68ac301-de11-4789-a24a-919305866909.png)


## VerifyLeaf

Функция verifyLeaf выполняет проверку листа в дереве Merkle и возвращает значение типа bool, указывающее, принадлежит ли указанный лист дереву Merkle.

Входные параметры функции:

leaf: значение листа, который требуется проверить. <br/>
proof: массив, содержащий значения доказательства, необходимые для проверки листа. <br/>

Работа функции заключается в выполнении следующих шагов: <br/>

Начальное значение переменной hash устанавливается равным значению проверяемого листа leaf.

Для каждого элемента proofElement в массиве proof вычисляется новое значение hash путем объединения текущего значения hash с proofElement и хэширования результата.
Если hash равен корню дерева Merkle, то функция возвращает true, иначе false.

Таким образом, функция verifyLeaf используется для проверки, принадлежит ли определенный лист дереву Merkle, на основе значения листа и доказательства, в котором указано расположение листа в дереве. Эта функция может быть использована для проверки подлинности данных, таких как транзакции или участники в airdrop-программах, используя дерево Merkle в качестве инструмента безопасности.

![image](https://user-images.githubusercontent.com/66798677/228098562-54cd1cf7-5a8f-4b87-bf68-91eed4c520ce.png)

Для того чтобы воспользоваться verifyLeaf, вам достаточно ввести в первое поле адрес и во второе пруфы которые доказывают принадлежность адреса к MerkleTree, соотвественно к айрдропу (токендропу). Таким образом при верном вводе данных и подтверждением принадлежности всплывёт данное окно:

![image](https://user-images.githubusercontent.com/66798677/228097066-1bdc9253-3da5-4645-a9a9-05ec26a06520.png)

Визуально подверждающее вашу принадлежность к айрдропу.

Адреса используются заранее установленные для данного айрдропа, также в самом коде смарт-контракта в комментариях указаны входные данные для теста
![image](https://user-images.githubusercontent.com/66798677/228097259-a93d8fd5-d944-4c3b-848d-fc5dffde7e7b.png)

Также в случае неверных данных, или отсуствием вашей принадлежности к айрдропу выходит данный визуальный элемент в виде notification.
![image](https://user-images.githubusercontent.com/66798677/228097454-b3b56daf-211c-4606-9220-729d352fbd2b.png)




## Claim

Функция claim позволяет участникам получить токены в рамках airdrop-программы.

Входной параметр функции:

_proof: массив значений, содержащий доказательство принадлежности адреса пользователя к дереву Merkle. <br/>

Работа функции заключается в выполнении следующих шагов: <br/>

Вызов require, который проверяет, что адрес, от имени которого выполняется функция claim, еще не запросил выплату токенов. Если адрес уже запросил выплату, функция будет остановлена и возвратит сообщение об ошибке.

Создание хэша leaf на основе адреса, от имени которого выполняется функция, с помощью функции keccak256.

Вызов функции verifyLeaf для проверки того, что хэш leaf принадлежит дереву Merkle. Если доказательство _proof не соответствует указанному листу leaf в дереве, функция будет остановлена и возвратит сообщение об ошибке.

Установка значения флага claimed[msg.sender] в true, чтобы пометить, что адрес уже получил свою долю токенов.

Вызов внутренней функции _mint, которая выполняет выпуск новых токенов и отправляет их на адрес, от имени которого выполняется функция.

Таким образом, функция claim проверяет, что пользователь имеет право на получение токенов в рамках airdrop-программы, на основе его адреса и доказательства принадлежности к дереву Merkle, и выпускает токены на его адрес. Если адрес уже запросил выплату токенов, функция вернет сообщение об ошибке.

![image](https://user-images.githubusercontent.com/66798677/228098723-f8c1ba3c-0e90-47c6-a133-f72f6761a36d.png)

В случае с Claim, нужно ввести пруфы, а именно соседние хеши соседних адресов, которые также прописаны в комментариях смарт-контракта:
![image](https://user-images.githubusercontent.com/66798677/228097748-47663a68-8f88-418f-a571-2a3a65024af4.png)

Также имеются такие же визуальные элементы подверждающие успешную отправку токенов или неуспешную.

## Rainbowkit

Также реализована возможность подключать разные кошельки с помощью библиотеки Rainbowkit:

![image](https://user-images.githubusercontent.com/66798677/228099587-96125644-691e-4b38-a104-96852ea38e8a.png)

![image](https://user-images.githubusercontent.com/66798677/228099711-ea585d5e-f322-4aed-a462-27414902dea9.png)


## Фронт

Фронт реализован используя next.js + typescript
В стиле "Неоморфизм"

![image](https://user-images.githubusercontent.com/66798677/228099807-fa22ee33-451e-4238-9b02-ba0917f2dae4.png)

Для реализации взаимодействия фронта со смарт-контрактом нам необходимы address, abi контракта:
![image](https://user-images.githubusercontent.com/66798677/228100123-ef4a80f6-af63-48bb-886a-2be05f3a3adc.png)

Также нам нужен signer и contract:

signer - объект Signer из библиотеки ethers.js. Signer используется для подписывания транзакций, отправки запросов на выполнение методов контракта и взаимодействия с блокчейном.

contract - объект Contract из библиотеки ethers.js. Contract используется для взаимодействия с контрактом. Он хранит адрес контракта, его ABI и обработчик транзакций (в данном случае, объект signer).

Ну и конечно provider:
const provider = new ethers.providers.Web3Provider((window as any).ethereum)
 - создание объекта Web3Provider из библиотеки ethers.js. Web3Provider используется для взаимодействия с сетью через провайдера Web3, который доступен в окне браузера.

Данная функция необходима для notification в случае успеха и нет:
![image](https://user-images.githubusercontent.com/66798677/228100591-3e3875ec-e017-4266-aa86-4e30b920af1a.png)

A функция **encodePackedKeccak256** принимает строковое входное значение и возвращает строковый вывод, который представляет хэш-значение входной строки с использованием алгоритма keccak256:
![image](https://user-images.githubusercontent.com/66798677/228101298-dd36e856-367f-4bc3-80ef-5f84288e493b.png)

Функция **parseHexArray** для того чтобы распарсить proofs которые передаются как JSON объект:
![image](https://user-images.githubusercontent.com/66798677/228101357-258e1e79-fac3-46da-a2d8-92783b389c87.png)

Функция **claimIn** достающая value из поля ввода и используя функцию из смарт-контракта, передающая параметр после того как распарсится в массив строк (с обработкой ошибок и дальнейшей передачей в notification для визуального уведомления пользователя):
![image](https://user-images.githubusercontent.com/66798677/228101460-b077d34e-1f5f-4afc-8043-459aeb887404.png)

Функция **verifyLeafIn** достающая адрес и доказательства, адрес переводится в хэш-значение с использованием алгоритма keccak256, а пруфы парсятся в массив строк и передаются в контракт, также происходит обработка ошибок и передача в notification:
![image](https://user-images.githubusercontent.com/66798677/228101769-b26dd7db-0e7b-45a8-8372-e34c5614b96b.png)


**Logo**
![image](https://user-images.githubusercontent.com/66798677/228102008-22400081-0cb9-4d17-8236-a1d86c0bb787.png)

Также в проекте была зайдействована библиотека AntDesign
